# Load all of the packages that you end up using
# in your analysis in this code chunk.
# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.
library(ggplot2)
library(knitr)
library(gridExtra)
library(GGally)
library(psych)
library(car)
# Load the Data
if (!file.exists("wineQualityReds.csv")) {
URL <- "https://s3.amazonaws.com/udacity-hosted-downloads/ud651/wineQualityReds.csv"
download.file(URL, destfile = "wineQualityReds.csv", method="curl")
}
df = read.csv("wineQualityReds.csv")
setwd("~/Google Drive/Udacity/Data_Analysis_with_R/Final Project/")
# Load all of the packages that you end up using
# in your analysis in this code chunk.
# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.
library(ggplot2)
library(knitr)
library(gridExtra)
library(GGally)
library(psych)
library(car)
# Load the Data
if (!file.exists("wineQualityReds.csv")) {
URL <- "https://s3.amazonaws.com/udacity-hosted-downloads/ud651/wineQualityReds.csv"
download.file(URL, destfile = "wineQualityReds.csv", method="curl")
}
df = read.csv("wineQualityReds.csv")
# get data frame dimensions
dim(df)
str(df)
summary(df)
sapply(df[2:13], sd)
pltList <- list()
for (i in 2:length(df)) {
#due to ggplot's "lazy evaluation" the data gets stored as is, and evaluated when you render the plot,
#so we need to store the data in each loop
breaks <- pretty(range(df[,i]), n = nclass.scott(df[,i]), min.n = 1)
bwidth <- breaks[2]-breaks[1]
pltList[[i-1]] <- ggplot(data=data.frame(value=df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df[i])) +
theme(legend.position="top")
}
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
par(mfrow=c(3, 4))
for (i in 2:length(df)) {
qqnorm(df[,i], main = paste("Normal Q-Q", colnames(df[i])))
qqline(df[,i],col = "blue")
}
pltList <- list()
for (i in 2:length(df)) {
#due to ggplot's "lazy evaluation" the data gets stored as is, and evaluated when you render the plot,
#so we need to store the data in each loop
breaks <- pretty(range(df[,i]), n = nclass.scott(df[,i]), min.n = 1)
bwidth <- breaks[2]-breaks[1]
pltList[[i-1]] <- ggplot(data=data.frame(value=df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_x_log10() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df)[i]) +
theme(legend.position="top")
}
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
df$fixed.acidity.log <- log10(df$fixed.acidity)
df$volatile.acidity.log <- log10(df$volatile.acidity)
df$chlorides.log <- log10(df$chlorides)
df$sulphates.log <- log10(df$sulphates)
par(mfrow=c(3, 4))
studyProp <- c('fixed.acidity.log', 'volatile.acidity.log', 'citric.acid', 'residual.sugar', 'chlorides.log', 'free.sulfur.dioxide', 'total.sulfur.dioxide', 'density', 'pH', 'sulphates.log', 'alcohol', 'quality')
dfStudy <- df[names(df) %in% studyProp]
for (i in 1:length(dfStudy)) {
qqnorm(dfStudy[,i], main = paste("Normal Q-Q", colnames(dfStudy)[i]))
qqline(dfStudy[,i],col = "blue")
}
ggplot(data = df, aes(x = quality)) +
geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 1) +
scale_fill_gradient("Count", low = "green", high = "red") +
stat_function(fun=dnorm, color="blue", arg=list(mean=mean(df$quality), sd=sd(df$quality))) +
geom_vline(xintercept=median(df$quality), size = 1.5, linetype = 3) +
scale_x_discrete(breaks = seq(0, 10, 1)) +
coord_cartesian(c(0,10)) +
xlab('Wine quality')
shapiro.test(df$quality)
qqnorm(df$quality)
qqline(df$quality, col = "blue")
#ggpairs(dfStudy)
cor(dfStudy)
corProp <- c('fixed.acidity.log', 'volatile.acidity.log', 'citric.acid', 'chlorides.log', 'total.sulfur.dioxide', 'density', 'sulphates.log', 'alcohol', 'quality')
dfCor <- df[names(df) %in% corProp]
dfCor <- dfCor[c(1,2,3,4,6,7,8,9,5)]
pltList <- list()
for (i in 1:8) {
pltList[[i]] <- ggplot(aes_string(x = 'quality', y = colnames(dfCor)[i]),
data = dfCor) +
geom_boxplot(aes_string(group = 'quality')) +
geom_line(color = "blue", stat = "summary", fun.y = median) +
scale_x_continuous(limits = c(2,9), breaks = seq(3,8,1))
}
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=4)))
dfCor$quality.bucket <- cut(dfCor$quality, breaks = c(0, 4, 6, 10),right = TRUE, labels = c("Bad", "Medium", "Good"))
View(dfCor)
pltList <- list()
for (i in 1:8) {
pltList[[i]] <- ggplot(aes_string(x = 'quality.bucket',
y = colnames(dfCor)[i],
group=1),
data = dfCor) +
geom_boxplot(aes_string(group = 'quality.bucket')) +
geom_line(color = "blue", stat = "summary", fun.y = median)
}
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=4)))
scatterplotMatrix(~citric.acid + fixed.acidity.log + volatile.acidity.log + density + total.sulfur.dioxide + sulphates.log + alcohol|quality.bucket, data = dfCor)
dfCor <- dfCor[c(1,2,3,5,6,7,8,4,9,10)]
pltList <- list()
for (i in 1:7) {
pltList[[i]] <- ggplot(aes_string(x = 'alcohol',
y = colnames(dfCor)[i],
colour = 'quality.bucket'),
data = dfCor) +
stat_density2d(aes(alpha = ..level..)) +
theme(legend.position="left")
}
do.call(grid.arrange, c(pltList, list(nrow=7, ncol=1)))
P1Prop <- c('volatile.acidity.log', 'citric.acid', 'sulphates.log', 'alcohol', 'quality')
dfP1 <- df[names(df) %in% P1Prop]
dfP1 <- dfP1[c(1,2,4,5,3)]
dfP1$quality.bucket <- cut(dfP1$quality, breaks = c(0, 4, 6, 10),right = TRUE, labels = c("Bad", "Medium", "Good"))
pltList <- list()
for (i in 1:4) {
pltList[[i]] <- ggplot(aes_string(x = 'quality.bucket',
y = colnames(dfP1)[i],
group=1),
data = dfP1) +
geom_point(aes_string(color = 'quality.bucket'), position = position_jitter()) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle(paste(colnames(dfP1)[i], 'vs wine quality'))
}
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=2)))
P1Prop <- c('volatile.acidity.log', 'citric.acid', 'sulphates.log', 'alcohol', 'quality')
dfP1 <- df[names(df) %in% P1Prop]
dfP1 <- dfP1[c(1,2,4,5,3)]
dfP1$quality.bucket <- cut(dfP1$quality, breaks = c(0, 4, 6, 10),right = TRUE, labels = c("Bad", "Medium", "Good"))
pltList <- list()
for (i in 1:4) {
pltList[[i]] <- ggplot(aes_string(x = 'quality.bucket',
y = colnames(dfP1)[i],
group=1),
data = dfP1) +
geom_point(aes_string(color = 'quality.bucket'), position = position_jitter()) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle(paste(colnames(dfP1)[i], 'vs wine quality')) +
guides(color = F)
}
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=2)))
ggplot(aes(x = alcohol,
y = exp(volatile.acidity.log),
colour = quality.bucket),
data = dfP1) +
stat_density2d(aes(alpha = ..level..)) +
theme(legend.position='left') +
ggtitle('Alcohol vs Volatile Acidity by wine quality') +
xlab('Alcohol (% Volume)') +
ylab('Volatilile Adidity (g/dm^3)') +
theme_classic()
ggplot(aes(x = quality,
y = exp(sulphates.log),
fill = quality.bucket,
group=1),
data = dfP1) +
geom_boxplot(aes(group = quality)) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle('Sulphates vs Quality') +
ylab('Sulphates (g/dm^3)') +
scale_x_discrete(seq(3,8,1)) +
coord_cartesian(c(2,9))
breaks <- pretty(range(df[,1]), n = nclass.scott(df[,1]), min.n = 1)
pretty(range(df[,1]), n = nclass.scott(df[,1]), min.n = 1)
pretty(range(df[,13]), n = nclass.scott(df[,13]), min.n = 1)
dim(pretty(range(df[,13]), n = nclass.scott(df[,13]), min.n = 1))
length(pretty(range(df[,13]), n = nclass.scott(df[,13]), min.n = 1))
length(pretty(range(df[,2]), n = nclass.scott(df[,2]), min.n = 1))
length(pretty(range(df[,4]), n = nclass.scott(df[,4]), min.n = 1))
length(pretty(range(df[,5]), n = nclass.scott(df[,5]), min.n = 1))
range(df[,13])
pretty(range(df[,13]))
pretty(range(df[,10]))
pretty(range(df[,4]))
# Create an empty list
pltList <- list()
# for each property in the df Datafreme starting in 2 (after the index variable X)
for (i in 2:length(df)) {
#due to ggplot's "lazy evaluation" the data gets stored as is, and evaluated when you render the plot,
#so we need to store the data in each loop
# Define the best binwidth
breaks <- pretty(range(df[,i]))
bwidth <- breaks[2]-breaks[1]
pltList[[i-1]] <- ggplot(data=data.frame(value=df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df[i])) +
theme(legend.position="top")
}
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
# Load all of the packages that you end up using
# in your analysis in this code chunk.
# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.
library(ggplot2)
library(knitr)
library(gridExtra)
library(GGally)
library(psych)
library(car)
# Load the Data
if (!file.exists("wineQualityReds.csv")) {
URL <- "https://s3.amazonaws.com/udacity-hosted-downloads/ud651/wineQualityReds.csv"
download.file(URL, destfile = "wineQualityReds.csv", method="curl")
}
df = read.csv("wineQualityReds.csv")
dim(df)
str(df)
summary(df)
sapply(df[2:13], sd)
# Create an empty list
pltList <- list()
# for each property in the df Datafreme starting in 2 (after the index variable X)
for (i in 2:length(df)) {
#due to ggplot's "lazy evaluation" the data gets stored as is, and evaluated when you render the plot,
#so we need to store the data in each loop
# Define the best binwidth
breaks <- pretty(range(df[,i]))
bwidth <- breaks[2]-breaks[1]
pltList[[i-1]] <- ggplot(data=data.frame(value=df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df[i])) +
theme(legend.position="top")
}
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
nclass.scott(df[,3])
nclass.scott(df[,13])
# Create an empty list
pltList <- list()
# for each property in the df Datafreme starting in 2 (after the index variable X)
for (i in 2:length(df)) {
#due to ggplot's "lazy evaluation" the data gets stored as is, and evaluated when you render the plot,
#so we need to store the data in each loop
# Define the best binwidth
breaks <- pretty(range(df[,i]), n = nclass.scott(df[,i])/2, min.n = 1)
bwidth <- breaks[2]-breaks[1]
pltList[[i-1]] <- ggplot(data=data.frame(value=df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df[i])) +
theme(legend.position="top")
}
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
# Create or empty list
pltList <- list()
# for each property in the df Datafreme starting in 2 (after the index variable X)
for (i in 2:length(df)) {
# Binwith must be dynamic, so let's define best value for each property
# Compute a sequence of about n+1 equally spaced ‘round’ values
breaks <- pretty(range(df[,i]), n = nclass.scott(df[,i])/2, min.n = 1)
# Compute the difference between the break values
bwidth <- breaks[2]-breaks[1]
# Store into the list of plots the ciorent plot
pltList[[i-1]] <- ggplot(data = data.frame(value = df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_x_log10() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df)[i]) +
theme(legend.position = "top")
}
# Once ended the loop arrange all the plots together
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
# Create or empty list
pltList <- list()
# for each property in the df Datafreme starting in 2 (after the index variable X)
for (i in 2:length(df)) {
# Binwith must be dynamic, so let's define best value for each property
# Compute a sequence of about n+1 equally spaced ‘round’ values
breaks <- pretty(range(df[,i]), n = nclass.scott(df[,i]), min.n = 1)
# Compute the difference between the break values
bwidth <- (breaks[2]-breaks[1])/2
# Store into the list of plots the ciorent plot
pltList[[i-1]] <- ggplot(data = data.frame(value = df[,i]), aes(value, ..density..)) +
geom_histogram(aes(fill = ..count..), binwidth = bwidth) +
geom_density() +
scale_x_log10() +
scale_fill_gradient("Count", low = "green", high = "red") +
xlab(colnames(df)[i]) +
theme(legend.position = "top")
}
# Once ended the loop arrange all the plots together
do.call(grid.arrange, c(pltList, list(nrow=3, ncol=4)))
ggplot(data = df, aes(x = quality)) +
geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 1) +
scale_fill_gradient("Count", low = "green", high = "red") +
stat_function(fun=dnorm, color="blue", arg=list(mean=mean(df$quality), sd=sd(df$quality))) +
geom_vline(xintercept=median(df$quality), size = 1.5, linetype = 3) +
scale_x_discrete(breaks = seq(0, 10, 1)) +
coord_cartesian(c(0,10)) +
xlab('Wine quality')
shapiro.test(df$quality)
# Setting Array Rows/Cols
par(mfrow=c(1, 1))
# Plot the Normal Q-Q Plot
qqnorm(df$quality)
# Plot the Normal Line in Blue color
qqline(df$quality, col = "blue")
finalProp <- c('volatile.acidity.log', 'citric.acid', 'sulphates.log', 'alcohol', 'quality', 'quality.bucket')
dfFinal <- dfCor[names(dfCor) %in% finalProp]
View(dfFinal)
dfFinal$volatile.acidity.log <- exp(dfFinal$volatile.acidity.log)
dfFinal$sulphates.log <- exp(dfFinal$sulphates.log)
View(dfFinal)
colnames(dfFinal) <- c('Citric Acid', 'Volatile Acidity', 'Sulphates', 'Alcohol', 'Quality')
View(dfFinal)
colnames(dfFinal) <- c('Citric Acid', 'Volatile Acidity', 'Sulphates', 'Alcohol', 'Quality Rate', 'Qualification')
View(dfFinal)
# Create or empty list
pltList <- list()
# for each property in the df Datafreme do
for (i in 1:4) {
# Store into the list of plots the current plot
pltList[[i]] <- ggplot(aes_string(x = 'Qualification',
y = colnames(dfFinal)[i],
group=1),
data = dfFinal) +
geom_point(aes_string(color = 'Qualification'), position = position_jitter()) +
stat_smooth(size=1, colour = 'red', method = 'gam') +
ggtitle(paste(colnames(dfFinal)[i], 'vs wine quality')) +
guides(color = F)
}
# Once ended the loop arrange all the plots together
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=2)))
# Selecting the Most Important properties
finalProp <- c('volatile.acidity.log', 'citric.acid', 'sulphates.log', 'alcohol', 'quality', 'quality.bucket')
# Create new Dataframe with only the Important Properties
dfFinal <- dfCor[names(dfCor) %in% finalProp]
# Get back to original values the properties transformed
dfFinal$volatile.acidity.log <- exp(dfFinal$volatile.acidity.log)
dfFinal$sulphates.log <- exp(dfFinal$sulphates.log)
# Renaming columns
colnames(dfFinal) <- c('CitricAcid', 'VolatileAcidity', 'Sulphates', 'Alcohol', 'QualityRate', 'Qualification')
# Create or empty list
pltList <- list()
# for each property in the df Datafreme do
for (i in 1:4) {
# Store into the list of plots the current plot
pltList[[i]] <- ggplot(aes_string(x = 'Qualification',
y = colnames(dfFinal)[i],
group=1),
data = dfFinal) +
geom_point(aes_string(color = 'Qualification'), position = position_jitter()) +
stat_smooth(size=1, colour = 'red', method = 'gam') +
ggtitle(paste(colnames(dfFinal)[i], 'vs wine quality')) +
guides(color = F)
}
# Once ended the loop arrange all the plots together
do.call(grid.arrange, c(pltList, list(nrow=2, ncol=2)))
ggplot(aes(x = Alcohol,
y = VolatileAcidity,
colour = Qualification),
data = dfFinal) +
stat_density2d(aes(alpha = ..level..)) +
theme(legend.position='left') +
ggtitle('Alcohol vs Volatile Acidity by wine quality') +
xlab('Alcohol (% Volume)') +
ylab('Volatilile Adidity (g/dm^3)') +
theme_classic()
ggplot(aes(x = Quality,
y = Sulphates,
fill = Qualification,
group=1),
data = dfFinal) +
geom_boxplot(aes(group = quality)) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle('Sulphates vs Quality') +
ylab('Sulphates (g/dm^3)') +
scale_x_discrete(seq(3,8,1)) +
coord_cartesian(c(2,9))
ggplot(aes(x = Quality,
y = Sulphates,
fill = Qualification,
group=1),
data = dfFinal) +
geom_boxplot(aes(group = Quality)) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle('Sulphates vs Quality') +
ylab('Sulphates (g/dm^3)') +
scale_x_discrete(seq(3,8,1)) +
coord_cartesian(c(2,9))
ggplot(aes(x = QualityRate,
y = Sulphates,
fill = Qualification,
group=1),
data = dfFinal) +
geom_boxplot(aes(group = QualityRate)) +
stat_smooth(size=1, colour = "red", method = 'gam') +
ggtitle('Sulphates vs Quality') +
ylab('Sulphates (g/dm^3)') +
scale_x_discrete(seq(3,8,1)) +
coord_cartesian(c(2,9))
is.na(df)
anyNA(df)
summary(subset(df, quality > 10 or qiality < 0))
summary(subset(df, quality > 10 or quality < 0))
summary(subset(df, quality > 10 || quality < 0))
dim(subset(df, quality > 10 || quality < 0))
dim(subset(df$quality, quality > 10 || quality < 0))
any(df, quality > 10 || quality < 0)
any(df$quality > 10 || df$quality < 0)
?"any"
any(df < 0)
